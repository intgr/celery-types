from typing import ClassVar

from _typeshed import Incomplete
from celery.utils.graph import GraphFormatter
from kombu import Consumer

class StepFormatter(GraphFormatter):
    blueprint_prefix: str
    conditional_prefix: str
    blueprint_scheme: dict[str, str]
    def label(self, step): ...
    def node(self, obj, **attrs): ...
    def edge(self, a, b, **attrs): ...

class Blueprint:
    GraphFormatter = StepFormatter
    name: ClassVar[str | None]
    state: Incomplete
    started: int
    default_steps: list[str]
    state_to_name: Incomplete
    types: Incomplete
    on_start: Incomplete
    on_close: Incomplete
    on_stopped: Incomplete
    shutdown_complete: Incomplete
    steps: Incomplete
    def __init__(
        self,
        steps: Incomplete | None = ...,
        name: Incomplete | None = ...,
        on_start: Incomplete | None = ...,
        on_close: Incomplete | None = ...,
        on_stopped: Incomplete | None = ...,
    ) -> None: ...
    def start(self, parent) -> None: ...
    def human_state(self) -> str: ...
    def info(self, parent): ...
    def close(self, parent) -> None: ...
    def restart(
        self, parent, method: str = ..., description: str = ..., propagate: bool = ...
    ) -> None: ...
    def send_all(
        self,
        parent,
        method,
        description: Incomplete | None = ...,
        reverse: bool = ...,
        propagate: bool = ...,
        args=...,
    ) -> None: ...
    def stop(self, parent, close: bool = ..., terminate: bool = ...) -> None: ...
    def join(self, timeout: Incomplete | None = ...) -> None: ...
    def apply(self, parent, **kwargs): ...
    def connect_with(self, other) -> None: ...
    def __getitem__(self, name): ...
    def claim_steps(self): ...
    def load_step(self, step): ...
    @property
    def alias(self): ...

class StepType(type):
    name: ClassVar[str | None]
    requires: tuple[type[Step] | str, ...]
    def __new__(cls, name, bases, attrs): ...

class Step(metaclass=StepType):
    name: ClassVar[str | None]
    label: ClassVar[str | None]
    conditional: bool
    requires: tuple[type[Step] | str, ...]
    last: bool
    enabled: bool
    def __init__(self, parent, **kwargs) -> None: ...
    def include_if(self, parent): ...
    def instantiate(self, name, *args, **kwargs): ...
    def include(self, parent): ...
    def create(self, parent) -> None: ...
    @property
    def alias(self): ...
    def info(self, obj) -> None: ...

class StartStopStep(Step):
    obj: Incomplete
    def start(self, parent): ...
    def stop(self, parent): ...
    def close(self, parent) -> None: ...
    def terminate(self, parent): ...
    def include(self, parent): ...

class ConsumerStep(StartStopStep):
    consumers: list[Consumer] | None
    def get_consumers(self, channel) -> list[Consumer]: ...
    def start(self, c) -> None: ...
    def stop(self, c) -> None: ...
    def shutdown(self, c) -> None: ...
