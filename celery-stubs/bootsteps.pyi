from typing import ClassVar

from _typeshed import Incomplete
from celery.utils.graph import GraphFormatter
from kombu import Consumer

class StepFormatter(GraphFormatter):
    blueprint_prefix: str
    conditional_prefix: str
    blueprint_scheme: dict[str, str]
    def label(self, step: Incomplete) -> Incomplete: ...
    def node(self, obj: Incomplete, **attrs: Incomplete) -> Incomplete: ...
    def edge(self, a: Incomplete, b: Incomplete, **attrs: Incomplete) -> Incomplete: ...

class Blueprint:
    GraphFormatter = StepFormatter
    name: ClassVar[str | None]
    state: Incomplete
    started: int
    default_steps: list[str]
    state_to_name: Incomplete
    types: Incomplete
    on_start: Incomplete
    on_close: Incomplete
    on_stopped: Incomplete
    shutdown_complete: Incomplete
    steps: Incomplete
    def __init__(
        self,
        steps: Incomplete | None = ...,
        name: Incomplete | None = ...,
        on_start: Incomplete | None = ...,
        on_close: Incomplete | None = ...,
        on_stopped: Incomplete | None = ...,
    ) -> None: ...
    def start(self, parent: Incomplete) -> None: ...
    def human_state(self) -> str: ...
    def info(self, parent: Incomplete) -> Incomplete: ...
    def close(self, parent: Incomplete) -> None: ...
    def restart(
        self, parent: Incomplete, method: str = ..., description: str = ..., propagate: bool = ...
    ) -> None: ...
    def send_all(
        self,
        parent: Incomplete,
        method: Incomplete,
        description: Incomplete | None = ...,
        reverse: bool = ...,
        propagate: bool = ...,
        args: Incomplete=...,
    ) -> None: ...
    def stop(self, parent: Incomplete, close: bool = ..., terminate: bool = ...) -> None: ...
    def join(self, timeout: Incomplete | None = ...) -> None: ...
    def apply(self, parent: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def connect_with(self, other: Incomplete) -> None: ...
    def __getitem__(self, name: str) -> Incomplete: ...
    def claim_steps(self) -> Incomplete: ...
    def load_step(self, step: Incomplete) -> Incomplete: ...
    @property
    def alias(self) -> Incomplete: ...

class StepType(type):
    name: ClassVar[str | None]
    requires: tuple[type[Step] | str, ...]
    def __new__(cls, name: Incomplete, bases: Incomplete, attrs: Incomplete) -> Incomplete: ...

class Step(metaclass=StepType):
    name: ClassVar[str | None]
    label: ClassVar[str | None]
    conditional: bool
    requires: tuple[type[Step] | str, ...]
    last: bool
    enabled: bool
    def __init__(self, parent: Incomplete, **kwargs: Incomplete) -> None: ...
    def include_if(self, parent: Incomplete) -> Incomplete: ...
    def instantiate(self, name: Incomplete, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def include(self, parent: Incomplete) -> Incomplete: ...
    def create(self, parent: Incomplete) -> None: ...
    @property
    def alias(self) -> Incomplete: ...
    def info(self, obj: Incomplete) -> None: ...

class StartStopStep(Step):
    obj: Incomplete
    def start(self, parent: Incomplete) -> Incomplete: ...
    def stop(self, parent: Incomplete) -> Incomplete: ...
    def close(self, parent: Incomplete) -> None: ...
    def terminate(self, parent: Incomplete) -> Incomplete: ...
    def include(self, parent: Incomplete) -> Incomplete: ...

class ConsumerStep(StartStopStep):
    consumers: list[Consumer] | None
    def get_consumers(self, channel: Incomplete) -> list[Consumer]: ...
    def start(self, c: Incomplete) -> None: ...
    def stop(self, c: Incomplete) -> None: ...
    def shutdown(self, c: Incomplete) -> None: ...
